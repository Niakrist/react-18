import React, { useMemo, useState, useTransition } from "react";
import { defaultItems } from "./defaultItems";

// CuncorrentMode делает рендер параллельным, может происходить сразу несколько рендеров
// рендер становится прерываемым, в любой момент React можем поставить его на паузу

// Что решает?
// При вводе в input на каждый символ происходит ререндер и могут быть тяжнлые вычисления, что приводит к лагам
// Cuncorrent самостоятельно строит очередь приоритетов и сам опредеят, когда это перерисовку произвести
// React будут прерывать ререндер жо тех пор, пока пользователь не остановится.
// (реализация от нас скрыта) и публичного API взаимодействия нет

// Фундаментальное изменение внутреннего механизма работы React. Это набор новых возможностей,
// которые позволяют React работать над несколькими задачами одновременно, не блокируя основной поток браузера.

// Как программист может применять Concurrent Mode
// 1. Использование createRoot - Использование корневой API включает базовые возможности конкурентного режима.
// 2. Главный инструмент для рядового разработчика startTransition и useTransition
// 3. Отложенные значения с useDeferredValue. При получение значений из пропсов или контекста
// 4. Прогрессивная загрузка с Suspense

// Ментальная модель: Приоритеты обновлений
// 1. Высокий приоритет (High Priority) — то, что пользователь делает прямо сейчас:
// - Ввод текста
// - Наведение мыши
// - Нажатие кнопки
// - Анимации
// 2. Низкий приоритет (Low Priority) — то, что можно отложить:
// - Фильтрация большого списка
// - Загрузка данных для невидимой части страницы
// - Предзагрузка контента
// - Тяжелые вычисления

// Когда использовать useTransition - для "фоновых" обновлений, которые могут подождать
// 1. Операция занимает > 50-100ms (заметно для пользователя)
// 2. Пользователь может выполнять другие действия во время операции
// 3. Есть визуальная обратная связь (isPending)
// 4. Можно отложить результат без потери функциональности
// 5. Операция не критична для следующего действия пользователя
// a) Фильтрация/поиск по большому списку
// b) Переключение табов с "тяжелым" контентом
// c) Обновление графика/диаграммы
// d) Сложные сортировки
// e) Навигация с предзагрузкой
// Когда НЕ использовать useTransition -  для действий, которые пользователь совершает "здесь и сейчас" и ожидает мгновенной реакции.
// 1. Операция быстрая (< 50ms)
// 2. Пользователь ожидает немедленного результата
// 3. От операции зависит следующее действие пользователя
// 4. Нельзя показать состояние загрузки
// 5. Это простое обновление состояния (счетчик, toggle и т.д.)
// a) Простые обновления состояния
// b) Обновления, от которых зависит UI немедленно
// c) Валидация форм при вводе
// d) Анимации и переходы
// e) Безусловное использование для всего
// f) Когда isPending не используется

export const ConcurrentModeTransition = () => {
  const [value, setValue] = useState("");
  const [filterValue, setFilterValue] = useState("");
  const [items] = useState(defaultItems);
  const [isPending, startTransition] = useTransition();

  const filterItems = useMemo(() => {
    return items.filter((item) =>
      item.name.toLowerCase().includes(filterValue),
    );
  }, [filterValue, items]);

  const onChangeValue = (
    e: React.ChangeEvent<HTMLInputElement, HTMLInputElement>,
  ) => {
    setValue(e.target.value);

    startTransition(() => {
      setFilterValue(e.target.value);
    });
  };

  return (
    <>
      <input type="text" value={value} onChange={onChangeValue} />

      {isPending && (
        <ul>
          {new Array(10).fill(1).map((_, index) => {
            return (
              <li
                style={{
                  display: "block",
                  padding: 5,
                  backgroundColor: "#c4c4c4",
                }}
                key={index}
              >
                {index}
              </li>
            );
          })}
        </ul>
      )}

      <div>
        {filterItems.map((item) => (
          <div key={item.id}>
            <div>id = {item.id}</div>
            <div>item = {item.name}</div>
          </div>
        ))}
      </div>
    </>
  );
};
